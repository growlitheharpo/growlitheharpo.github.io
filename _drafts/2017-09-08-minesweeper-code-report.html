---
title: James Keats - Game Programmer
layout: default
---
<div class="contentBlock">
    <h2 class="elementTextWrapper">Artificial Opponents - Minesweeper Code Report</h2>
    <div>
        <div class="elementTextWrapper">
            <div>
                <h3>General Approach</h3>
            </div>
        </div>
        <div class="elementTextWrapper">
            <div>
                <p>As was planned <a alt="Minesweeper Planning" ref="{% post_url 2017-09-02-minesweeper-planning %}" target="_blank" itle="Minesweeper Planning">in the planning post</a>, I approached Minesweeper in a similar way o what was outlined by Bai Li (luckytoilet) in the blog post "<a lt="How to Write your own Minesweeper AI" ref="https://luckytoilet.wordpress.com/2012/12/23/2125/" rel="nofollow" target="_blank" itle="How to Write your own Minesweeper AI">How to Write your own Minesweeper AI</a>".</p>
            </div>
        </div>
        <div class="elementTextWrapper">
            <div>
                <p>Essentially, the most basic minesweeper strategy is used first: find all cells that can be flagged as ines or known to be clear using basic arithmetic (i.e., if a cell has a count of 1 and 1 mine is lready flagged next to it, all others can be revealed; if a cell has a count of 1 and only 1 nknown neighbor, the unknown cell must be a mine).</p>
            </div>
        </div>
        <div class="elementTextWrapper">
            <div>
                <p>If this approach fails, we use the brute force "Tank algorithm" described by Bai Li, which ecursively determines all valid states of the board, then uses commonalities between the possible alid states to make its next move.</p>
            </div>
        </div>
        <div class="elementTextWrapper">
            <div>
                <p>This method has been very successful against the default configurations that we were given for nitial testing.</p>
            </div>
        </div>
        <div class="elementTextWrapper">
            <div>
                <h3>Classes Used</h3>
            </div>
        </div>
        <div class="elementTextWrapper">
            <div>
                <p><b>BoardState</b></p>
                <p></p>
                <ul>
                    <li>This holds an array of bytes that represent the state of the board as the AI or player would see t.</li>
                    <ul>
                        <li>A value of -2 means the cell has been flagged as a mine.</li>
                        <li>A value of -1 means the cell is unknown.</li>
                        <li>A value &gt;= 0 represents the adjacent mine count of the cell.</li>
                    </ul>
                    <li>It also holds the width and height of the board, as well as the flag count, the mine count, and he count of all revealed cells.</li>
                </ul>
                <p></p>
            </div>
        </div>
        <div class="elementTextWrapper">
            <div>
                <p><b>AIGameView</b></p>
                <p></p>
                <ul>
                    <li>This class holds a "master" instance of BoardState which represents the actual state of the ame.</li>
                    <li>It also holds a queue of cells that are known to be clickable.</li>
                </ul>
                <p></p>
            </div>
        </div>
        <div class="elementTextWrapper">
            <div>
                <p><b>Free Functions</b></p>
                <p></p>
                <ul>
                    <li>The "Tank Algorithm" outlined below exists as a set of free functions in order to make the IGameView class cleaner.</li>
                </ul>
                <p></p>
            </div>
        </div>
        <div class="elementTextWrapper">
            <div>
                <h3>Algorithms</h3>
            </div>
        </div>
        <div class="elementTextWrapper">
            <div>
                <p>The following process is followed when the DLL receives a request for a click from the main game:</p>
            </div>
        </div>
        <div class="elementTextWrapper">
            <div>
                <p>A simplified version of this flow:</p>
                <p></p>
                <ul>
                    <li>AI gets a click request from the game.</li>
                    <li>If there are safe cells already in our queue, go no further and use those. Otherwise...</li>
                    <li>If it's our first click, go no further and choose a random cell. Otherwise...</li>
                    <li>Copy the master game state from the game.</li>
                    <li>Attempt to flag mines and fill the queue using basic arithmetic and known mines/counts.</li>
                    <li>If there are safe cells in the queue from this method, go no further and use those. Otherwise...
                    </li>
                    <li>If there aren't many cells revealed (5 was chosen as a limit), go no further and choose a random ell. Otherwise...</li>
                    <li>Begin the tank algorithm:</li>
                    <ul>
                        <li>Make a list of all unknown cells that border a known cell.</li>
                        <li>Begin a recursive call that checks every possible combination of mine/empty for the list of nknown cells. Whenever a combination that is valid based on our known data is found, add it o a list of solutions.</li>
                        <li>When the recursive call completes, loop through all border cells. If there are any that are ines in every valid solution, flag them as a mine. If there are any that are empty in every alid solution, add them to the clickable queue. Go no further, and use those.</li>
                        <li>If no cells have been clicked, use the number of times each cell was empty divided by the umber of valid solutions to determine a "probability" that each cell is empty. Choose the ell with the highest probability of being empty, add it to the queue, and use it.</li>
                    </ul>
                </ul>
                <p></p>
            </div>
        </div>
        <div class="elementTextWrapper">
            <div>
                <p>Here is a more in-depth overview of the process:</p>
            </div>
        </div>
        <div name="elementTextWrapper"> <img style="width:100%; text-align:center;" rc="/assets/img/blog/artificial-opponents/minesweeper_flowchart.png"></img> </div>
        <div class="elementTextWrapper">
            <div>
                <h3>Compromises &amp; Expectations</h3>
            </div>
        </div>
        <div class="elementTextWrapper">
            <div>
                <p>One of my hopes was to multithread the Tank Algorithm as each recursive call is able to rely entirely n method arguments, although it needs to push valid solutions into a global queue. In the end, I ecided to abandon this idea because the complexity involved in getting it working was taking too uch time. For reasons I never determined, the recursion failed after a depth of only 2 or 3 when unning on threads, never reaching the much lower depths needed to solve the problem. It is also ossible that this solution would not have provided any real performance boost in the end anyway, iven how expensive it is to create and join threads.</p>
            </div>
        </div>
        <div class="elementTextWrapper">
            <div>
                <p>Partially because I was never able to get the multithreading working, I introduced limits on the tank lgorithm to avoid it freezing the game for long stretches of time. The length of the border list it s checking has a significant impact on the time it takes; in fact, it runs at O(2^n). I decided hrough testing that it should abandon using this algorithm if the length of this list is greater han 20, and even that involves <span>1,048,576 function calls which briefly seizes the game. In a imilar vein, I choose to not even attempt the tank algorithm if less than 5 cells have been evealed. A quantity this small implies we are in the early stages of the game and the AI has so ar clicked cells that only revealed a single data point, meaning the algorithm would not be ble to find any valid solutions, and it is not worth the time to run it.</span></p>
            </div>
        </div>
        <div class="elementTextWrapper">
            <div>
                <p>This AI has performed very well against the configurations were were provided for testing, which ncluded the following boards: 25x25 w/ 40 mines, 12x12 w/ 7 mines, and 7x7 w/ 4 mines. The win ercentage in these scenarios hovers between 80-90%, and it runs very quickly. My hope is that these tatistics will hold up to some degree with whatever values are used for the competition in-class.
                </p>
            </div>
        </div>
        <div class="elementTextWrapper">
            <div>
                <h3>References</h3>
            </div>
        </div>
        <div class="elementTextWrapper">
            <div>
                <p><span><span>Li, Bai. </span><i>“How to Write your own Minesweeper AI”</i><span>. Dec 23, 012.&nbsp;</span><a ref="https://luckytoilet.wordpress.com/2012/12/23/2125/">https://luckytoilet.wordpress.com/2012/12/23/2125/</a></span>
                </p>
            </div>
        </div>
    </div>
</div>